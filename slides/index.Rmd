---
title: "Presentation Ninja"
subtitle: "&#x2694;&#xFE0F; xaringan +<br/>&#x1F60E; xaringanthemer"  
author: 
  - "Yihui Xie"
  - "Garrick Aden-Buie"
date: '`r Sys.Date()`'
output:
  xaringan::moon_reader:
    css: ["xaringan-themer.css", "custom.css"]
    nature:
      slideNumberFormat: "%current%/%total%"
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: true
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(
  fig.width = 9, fig.height = 3.5, fig.retina = 3,
  out.width = "100%",
  cache = FALSE,
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  hiline = TRUE
)
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
# xaringanthemer::style_duo_accent(
#   primary_color = "#1381B0",
#   secondary_color = "#FF961C",
#   inverse_header_color = "#FFFFFF"
# )
xaringanthemer::style_duo_accent(
  primary_color = "#005c8b",
  secondary_color = "#0073ae",
  inverse_header_color = "#FFFFFF"
)
```

```{r xaringanExtra, echo=FALSE}
#devtools::install_github("gadenbuie/xaringanExtra")
# xaringanExtra::use_xaringan_extra(c("tile_view", "animate_css", "tachyons"))

xaringanExtra::use_clipboard()
xaringanExtra::use_fit_screen()
xaringanExtra::use_extra_styles(
  hover_code_line = TRUE,         #<<
  mute_unhighlighted_code = TRUE  #<<
)
xaringanExtra::use_share_again()
xaringanExtra::use_scribble()
xaringanExtra::use_tile_view()
xaringanExtra::use_tachyons()
xaringanExtra::use_panelset()
```

# Sumário

1. [R e RStudio](#r-rstudio)
2. [Introdução](#introducao)
3. [Projetos](#projetos)
4. [Importação de dados](#importacao)

---

class: inverse center middle
name: r-rstudio

# R e RStudio 

---

## Instalação do R

.pull-left[
<br>
<br>
<br>
<br>
<br>
- [Download](https://cran.r-project.org/)
- Use a versão mais recente `r emo::ji("wink")` 
]
.pull-right[
<br>
<br>
<br>
```{r, fig.align='center', out.width='60%', echo=FALSE}
knitr::include_graphics("img/01-r-logo.svg")
```
]

---

## Instalação do R

```{r, fig.align='center', out.width="80%", echo=FALSE}
knitr::include_graphics("img/02-r-install.png")
```

---

## Instalação do RStudio

.pull-left[
<br>
<br>
<br>
<br>
<br>
- [Download](https://posit.co/download/rstudio-desktop/)
- Use a versão mais recente `r emo::ji("wink")` 
]
.pull-right[
<br>
<br>
<br>
<br>
<br>
```{r, fig.align='center', out.width="70%", echo=FALSE}
knitr::include_graphics("img/03-rstudio.png")
```
]

---

## Instalação do RStudio

```{r, fig.align='center', out.width="80%", echo=FALSE}
knitr::include_graphics("img/04-rstudio-install.png")
```

---

### O que é o R?

> "R é um ambiente de software livre para computação estatística e gráficos." [R Development Core Team](https://cran.r-project.org/)

  - **Por que usar o R?**
  
    - É uma linguagem de programação que possui muitas ferramentar para a análise de dados;
    
    - É em código aberto e gratuito (*open source*);
    
    - Possui uma comunidade ativa de pessoas desenvolvedoras;
    
    - É flexível, permite desenvolver funções e pacotes para facilitar o trabalho;
    
    - Está disponível gratuitamente em diferentes plataformas: Linux, MacOS e Windows;
    
    - Mantido pela [R Development Core Team](https://cran.r-project.org/).
    
---

### RStudio

**RStudio** é uma IDE (*Integrated Development Environment*) da Linguagem R, isto é, um ambiente de desenvolvimento utilizado para editar e executar códigos em R. Ela é mantida pela [Posit](https://posit.co).

```{r, fig.align='center', out.width="80%", echo=FALSE}
knitr::include_graphics("img/05-rstudio.png")
```

---

### RStudio

**Editor/Scripts:** onde os códigos são escritos. O **RStudio** destaca algumas palavras e símbolos para facilitar a leitura do código.

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/06-rstudio-haydee.jpg")
```

---

### RStudio

**Console:** onde os códigos são executados e os resultados são exibidos. **O R vive aqui!**

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/07-rstudio-haydee.jpg")
```

---

### RStudio

**Environment:** painel com todos os objetos criados na sessão.

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/08-rstudio-haydee.jpg")
```

---

### RStudio

**History:** painel com um histórico dos comandos rodados.

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/09-rstudio-haydee.jpg")
```

---

### RStudio

**Files:** mostra os arquivos no diretório de trabalho. É possível navegar entre os diretórios.

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/10-rstudio-haydee.jpg")
```

---

### RStudio

**Plots:** painel onde os gráficos serão apresentados.

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/11-rstudio-haydee.jpg")
```

---

### RStudio

**Packages:** apresenta todos os pacotes instalados e carregados.

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/12-rstudio-haydee.jpg")
```

---

### RStudio

**Help:** janela onde a documentação das funções serão apresentadas.

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/13-rstudio-haydee.jpg")
```

---

### Atalhos

Conhecer os atalhos do teclado ajuda bastante durante a programação no **RStudio**.

- **CTRL + ENTER:** avalia/roda a linha selecionada no script;

- **ALT + –:** cria um sinal de atribuição (`<-`);

- **CTRL + SHIFT + M:** adiciona o operador pipe (`%>%` ou `|>`);

- **CTRL + SHIFT + C:** comenta a(s) linha(s) selecionada(s);

- **CTRL + SHIFT + D:** duplica a(s) linha(s) selecionada(s);

- **CTRL + 1:** altera o cursos para o script;

- **CTRL + 2:** altera o cursos para o console;

- **ALT + SHIFT + K:** mostra uma janela com todos os atalhos disponíveis.

<br>

No MacOS, substitua **CTRL** por **CMD** e **ALT** por **OPT**.

---

### Help! 

Ficou com dúvida sobre determinado pacote ou função?

  - Peça ajuda: **help**(nome_do_pacote) ou **?**nome_do_pacote;
  
  - Peça ajuda: **help**(nome_da_funcaoo) ou **?**nome_da_funcao;
  
<br>
  
```{r, eval=FALSE}
help(sum)
?sum
```

<br>

  - Se a dúvida persistir, procure no [Google](https://www.google.com/) ou no [Stack Overflow](https://stackoverflow.com/).
  
  - E se ainda estiver com dúvidas, pergunte para a comunidade:
  
    - há diversos grupos de Telegram, Twitter, Discourse e em outras redes sociais.

---

### [Cheat Sheets](https://rstudio.com/resources/cheatsheets/)

O **RStudio** disponibiliza algumas 'folhas de cola', as **Cheat Sheets**. Elas trazem um resumo de como utilizar diversos pacotes e até o próprio RStudio. Para acessá-las, basta clicar no menu `Help` e então em `Cheat Sheets`, ou através do site da [**Posit**](https://posit.co/resources/cheatsheets/).

[![Cheat Sheets](img/14-cheatsheet-rstudio.png)](https://rstudio.github.io/cheatsheets/rstudio-ide.pdf)

---

### O Ciclo da Ciência de Dados

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/15-ciclo-ciencia-de-dados.png")
```

---

### O Ciclo da Ciência de Dados no R

```{r, fig.align='center', out.width="700px", echo=FALSE}
knitr::include_graphics("img/16-ciclo-ciencia-de-dados-no-r.png")
```

---

class: inverse center middle
name: introducao

# Introdução

.center[(Acompanhe no arquivo `01-introducao.R`)]

---

### R como calculadora

O **R** permite realizar muitas operações matemáticas!

```{r}
2 + 5 # adição

9 - 4 # subtração

5 * 2 # multiplicação

7 / 5 # divisão
```

- **CTRL + ENTER:** executa a linha selecionada no script

---

### R como calculadora

```{r}
9 %% 4 # resto da divisão de 9 por 4

7 %/% 4 # parte inteira da divisão de 7 por 4

8 ^ 2 # potenciação

sqrt(1024) # radiciação
```

A ordem matemática das operações também vale do R.

---

### Funções matemáticas

```{r}
sin(1) # funções trigonométricas

log(1) # logaritmo natural (base e)

log10(10) # logaritmo na base 10

exp(0.5) # exponencial e^(1/2)
```

---

### Objetos

O **R** permite armazenar (salvar) valores dentro de um objeto.

Um **objeto** é um nome que guarda um valor, uma função ou uma base de dados.

- Para atribuir um valor a um objeto no R, utilizamos o operador `<-`.

.center[`nome_do_objeto <- valor`]

- Atalho: **ALT** + **–**: cria o `<-` sinal de atribuição.

---

#### Exemplo:

```{r}
nome <- "Fernando Oliveira Costa"
nome

idade <- 40
idade

cargo_ou_funcao <- "Gerente de Projetos"
cargo_ou_funcao

salario <- 12000.00
salario
```

---

### Nomes dos Objetos

Existem algumas regras para dar nomes aos objetos:

- os nomes devem começar com uma letra. E podem conter letras, números, `_` e `.`. Não usar acentuações e/ou espaços! O autor do livro [R for Data Science](https://r4ds.hadley.nz) recomenda usar **snake_case**, ou seja, palavras escritas em minúsculo separadas por underline (`_`).

- o R é **case sensitive**, isto é, faz a diferenciação entre as letras minúsculas e maiúsculas. Portanto, um objeto chamado `teste` é diferente de outro objeto chamado `Teste`.

```{r}
a <- 2
a

A <- 4
A
```

---

### Operadores Relacionais

- Igual a: **==**

- Diferente de: **!=**

- Maior que: **>**

- Maior ou igual a: **>=**

- Menor que: **<**

- Menor ou igual a: **<=**

---

### Operadores Relacionais

- Igual a: **==**

```{r}
TRUE == TRUE

TRUE == FALSE
```

- Diferente de: **!=**

```{r}
TRUE != TRUE

TRUE != FALSE
```

---

### Operadores Relacionais

- Maior que: **>**

```{r}
15 > 10

10 > 10
```

- Menor que: **<**

```{r}
3 < 5

10 < 5
```

---

### Operadores Relacionais

- Maior ou igual a: **>=**

```{r}
15 >= 10

15 >= 15
```

- Menor ou igual a: **<=**

```{r}
10 <= 10

10 <= 8
```

---

### Operadores Lógicos

- AND - E: **&**

Será verdadeiro (`TRUE`) se as duas condições forem verdadeiras

```{r}
x <- 15

  x > 10 & x <= 20
  
y <- 7

  y > 10 & y <= 15
```

---

### Operadores Lógicos

- OR - OU: **|**

Será verdadeiro (`TRUE`) se uma das duas condições for verdadeira

```{r}
x <- 5

  x >= 10 | x <= 15
  
y <- 2

  y >= 5 | y == 0
```

---

### Operadores Lógicos

- NOT - NEGAÇÃO: **!**

```{r}
!TRUE

!FALSE

x <- c(TRUE, FALSE, TRUE, FALSE)

  !x

y <- 8

  (!y < 5)
```

---

### Pertence

É possível verificar se um valor está inserido dentro de um conjunto de valores (vetor).

É representado pelo operador **%in%**.

```{r}
3 %in% c(1, 2, 3, 4, 5)

3 %in% c(4, 5, 6)

"a" %in% c("a", "b")

"a" %in% c("c", "d", "e")
```

---

### Tipos Básicos de dados

São os tipos de dados que podem ser representados na Linguagem R. É neles que são guardadas as informações.

- **Integer:** números inteiros

- **Double/Numeric:** números racionais

- **Logical:** tipos lógicos (`TRUE` ou `FALSE`)

- **Character:** texto (sempre entre aspas)

- **Factor:** dados categóricos

<br>

A função `class()` retorna o tipo de dado de um objeto.

---

### Números

Um número inteiro seguido de `L` será considerado do tipo **integer**:

```{r}
class(5L)
```

<br>

Números racionais serão considerados do tipo **double/numeric**:

```{r}
class(5)

class(5.1)
```

---

### Lógicos

Verdadeiro (`TRUE`) e Falso (`FALSE`) 

```{r}
class(TRUE)

class(FALSE)
```

<br>

O R entende o `TRUE` sendo igual a 1 (um) e o `FALSE` sendo igual a 0 (zero).

Isso significa que é possível realizar operações matemáticas com ele (por exemplo, somar):

```{r}
TRUE + FALSE + FALSE + TRUE + TRUE + TRUE + FALSE
```

---

### Textos

**Qualquer** código entre aspas (`""`) será interpretado como texto **character**:

```{r}
class("TEXTO")

ensino <- c("Médio", "Superior", "Fundamental", "Fundamental", "Médio")

class(ensino)

class("3")
```

---

### Fatores

Os fatores (ou factors) são usados para representar categorias.

```{r}
# Criando um factor

ensino_categorias <- factor(c("Médio", "Superior", "Fundamental", "Fundamental", "Médio"))

ensino_categorias

class(ensino_categorias)
```

<br>

A função `as.factor()` cria um objeto do tipo `factor` ou converte um objeto já existente.

Na linha `levels` aparecem os rótupos do fator.

---

### NA

**NA** representa um valor desconhecido ou ausente. As operações envolvendo um valor desconhecido também resultarão em valores desconhecidos (`NA`).

```{r}
NA > 10

NA + 10

NA / 5

10 == NA
```

---

### NA

```{r}
NA == NA
```

<br>
<br>

`is.na()` é a função que verifica se um objeto é `NA`.

```{r}
vetor_numerico <- c(NA, 1, 2, 3, 4, 5, NA)

is.na(vetor_numerico)

!is.na(vetor_numerico)
```

---

### na.rm = TRUE

Quando um vetor contém valores ausentes (`NA`), muitas funções não conseguem realizar os cálculos corretamente e retornam `NA` como resultado. Na maioria dos casos, o que se deseja é calcular o resultado ignorando os valores ausentes. Para isso, utiliza-se o argumento `na.rm = TRUE`, que instrui a função a remover os `NAs` antes de calcular.

```{r}
sum(vetor_numerico)

sum(vetor_numerico, na.rm = TRUE)

mean(vetor_numerico)

mean(vetor_numerico, na.rm = TRUE)
```

---

### Conversão de classes

```{r}
vetor_logical <- c(TRUE, TRUE, FALSE, TRUE, FALSE)

as.integer(vetor_logical) # converte para número inteiro

as.numeric(vetor_logical) # converte para número racional

as.character(vetor_logical) # converte para texto

as.factor(vetor_logical) # converte para fator
```

---

### Conversão de classes

```{r}
frutas <- c("amora", "banana", "melancia")

as.integer(frutas)

as.numeric(frutas)

as.character(frutas)

as.factor(frutas)
```

---

### Tipos de Objetos

No **R**, os quatro principais objetos são:

- Vetor;

- Matriz;

- Lista;

- Data Frame.

---

### Vetores

Armazenam elementos de uma **mesma classe** em apenas **uma dimensão**.

Para criá-los, basta passar os valores, separados por vírgulas, para a função `c()`.

<br>

```{r}
primeiro_semestre <- c("Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho")

primeiro_semestre

# retorna o comprimento do vetor — quantos elementos ele tem?

length(primeiro_semestre)
```

---

### Vetores

Para criar um vetor com uma sequência de números, basta utilizar o operador **:**

```{r}
# vetor de 1 a 10

1:10

# vetor de 10 a 1

10:1

# betor de -5 a 5

-5:5
```

---

### Vetores

Por serem conjuntos indexados, cada valor dentro de um vetor tem uma posição. Essa posição é dada pela ordem em que os elementos foram dispostos no momento em que o vetor é criado. Dessa forma, é possível acessar individualmente cada valor de um vetor.

Para isso, basta colocar o índice do valor que se deseja acessar dentro de **colchetes** `[]`:

```{r}
# primeiro elemento do vetor

primeiro_semestre[1]

# primeiro e segundo elemento do vetor

primeiro_semestre[1:2]
```

---

### Vetores

```{r}
# remove o primeiro elemento do vetor

primeiro_semestre[-1]

# seleciona o elemento seis até o quatro (e muda a ordem dos elementos)

primeiro_semestre[6:4]
```

É possível colocar um conjunto de índices dentro dos colchetes para pegar os valores contidos nessas posições:

```{r}
# seleciona o primeiro, o terceiro e o quinto elemento do vetor

primeiro_semestre[c(1, 3, 5)]
```

Essas operações são chamadas de **subsetting**, pois são acessados os subconjuntos de valores de um vetor.

---

### Vetores

**Classe do Vetor:**

Um vetor só pode guardar um tipo de objeto e ele terá sempre a mesma classe dos objetos que guarda.

Para saber a classe de um vetor, basta usar a função `class(nome_do_vetor)`.

<br>

```{r}
primeiro_semestre <- c("Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho")

class(primeiro_semestre)

anos_bissextos <- c(2000, 2004, 2008, 2012, 2016, 2020, 2024)

class(anos_bissextos)
```

---

### Vetores

**Coerção:**

Ao tentar misturar duas classes de elementos dentro de um vetor, o **R** vai apresentar o comportamento conhecido como **coerção**.

```{r}
segundo_semestre <- c(7, 8, 9, 10, 11, "Dezembro")

segundo_semestre

class(segundo_semestre)
```

Todos os elementos do vetor se transformaram em **texto**. Como um vetor só pode ter uma classe de objeto dentro dele, classes mais fracas serão sempre reprimidas pelas classes mais fortes.

.center[`character > numeric > integer > logical`]

---

### Vetores

**Operações com Vetores:**

É possível realizar operações aritméticas com vetores:

```{r}
vetor_numerico <- c(0, 5, 10, 15, 20)

vetor_numerico + 1
```

Ao rodar `vetor_numerico + 1`, o **R** adiciona 1 de cada um dos elementos do vetor. O mesmo acontece com qualquer outra operação aritmética.

```{r}
vetor_numerico * 2 # multiplica todos os elementos do vetor por 2

vetor_numerico - 1 # subtrai todos os elementos do vetor por 1
```

---

### Vetores

**Vetorização:**

Também é possível fazer operações que envolvem mais de um vetor:

```{r}
vetor1 <- c(1, 2, 3)

vetor2 <- c(10, 20, 30)

vetor1 + vetor2
```

<br>

O **R** vai alinhar os dois vetores e somar os elementos que estão na mesma posição.

---

### Vetores

**Reciclagem:**

Ocorre quando os dois vetores não possuem o mesmo tamanho:

```{r}
vetor1 <- c(1, 2)

vetor2 <- c(10, 20, 30, 40)

vetor1 + vetor2
```

<br>

O **R** alinhou os dois vetores e, como eles não possuem o mesmo tamanho, os elementos do `vetor1` foram repetidos para ficar do mesmo tamanho do `vetor2`. É como se o primeiro vetor fosse `c(1, 2, 1, 2)`.

---

### Vetores 

**Reciclagem:**

Um caso interessante ocorre quando o comprimento dos vetores não são múltiplos um do outro:

```{r warning=TRUE, message=TRUE}
vetor1 <- c(1, 2, 3)

vetor2 <- c(10, 20, 30, 40, 50)

vetor1 + vetor2
```

O **R** realizou a operação, repetindo cada valor do primeiro vetor até que os dois tivessem o mesmo tamanho. Na realidade, a operação realizada foi `c(1, 2, 3, 1, 2) + c(10, 20, 30, 40, 50)`.

Como essa operação não é intuitiva, o **R** devolveu um aviso dizendo que o comprimento do primeiro vetor não é múltiplo do comprimento do segundo vetor.

---

### Vetores

**Filtro:**

```{r}
numeros <- c(-3, -1, 3, 5, 7, 10, 15)
numeros > 3
```

Na primeira operação, o **R** fez uso da **Reciclagem**. Ele transformou o valor 3 em um vetor `c(3, 3, 3, 3, 3, 3, 3)` e testou (comparou) se `c(-3, -1, 3, 5, 7, 10, 15) > c(3, 3, 3, 3, 3, 3, 3)`.

```{r}
numeros[numeros > 3]
```

A segunda operação retornou as posições que receberam `TRUE` e não retornou os valores que receberam `FALSE`. Portanto, a segunda operação é equivalente a:

```{r}
numeros[c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)]
```

---

### Matrizes

São estruturas que correspondem às matrizes matemáticas, conjuntos bidimensionais contendo elementos dispostos em linhas e colunas. Assim como os vetores, todos os seus elementos são do mesmo tipo. São criadas utilizando a função `matrix()`:

```{r}
matriz1 <- matrix(c(1:12), nrow = 3, ncol = 4)

matriz1

class(matriz1)

dim(matriz1)
```

---

### Matrizes

É possível alterar a ordem de preenchimento da matriz (linhas ao invés de colunas)

```{r}
matriz2 <- matrix(c(1:12), nrow = 3, ncol = 4, byrow = TRUE)

matriz2

class(matriz2)

dim(matriz2)
```

---

### Matrizes

Também é possível adicionar colunas com `cbind()` e linhas com `rbind()`

```{r}
cbind(matriz1, rep(99, 3))

rbind(matriz1, rep(99, 4))
```

---

### Matrizes

**Operações com Matrizes:**

```{r}
# multiplica cada elemento da matriz por 2 (multiplicação escalar)

matriz1 * 2 

# retorna o resto da divisão de cada elemento da matriz1 pelo correspondente em matriz2

matriz1 %% matriz2 
```

---

### Listas

São um tipo especial de vetor que podem conter uma **coleção de diferentes classes**. Possuem uma **estrutura unidimensional**, contando apenas o número de elementos integrantes. São criados usando a função `list()`

```{r}
lista <- list(a = 1:10, b = c("T1", "T2", "T3", "T4"), TRUE, 2 + 2)

lista
```

- Os dois primeiros elementos têm nomes (`$a` e `$b`), enquanto os dois últimos são acessados por índices (`[[3]]` e `[[4]]`) pois não foram nomeados.

---

### Listas

```{r}
class(lista)
```

- A estrutura é realmente uma **lista**.

```{r}
dim(lista)
```

- O resultado **NULL** é esperado pois as listas no R não têm "dimensões" como vetores ou matrizes. Elas são estruturas mais gerais.

```{r}
length(lista)
```

- A lista apresenta 4 elementos, mesmo que alguns deles contenham vetores maiores por dentro.

---

## Data Frame

São tabelas **bidimensionais** (linhas e colunas), em que cada coluna pode ser de uma classe diferente. São criados com a função `data.frame()`:

```{r, echo=FALSE}
mtcars |> 
  head(n = 10) |> 
  knitr::kable()
```

---

### Data Frame

```{r}
# retorna a classe
class(mtcars)

# retorna o número de colunas
ncol(mtcars)

# retorna o número de linhas
nrow(mtcars)

# retorna a dimensão do dataframe — o número de linhas e de colunas
dim(mtcars)
```

---

### Data Frame

```{r}
# retorna a estrutura interna do objeto mtcars, como: tipo do objeto, 
# número de observações (linhas) e variáveis (colunas), nome de cada variável, 
# tipo (classe) de cada variável e os primeiros valores de cada variável

str(mtcars)
```

---

### Data Frame

```{r}
# retorna as seis primeiras linhas de uma tabela
head(mtcars)

# retorna as seis últimas linhas de uma tabela
tail(mtcars)
```

---

### Data Frame

**Selecionando as Colunas:**

Para selecionar as colunas de um dataframe, utilizamos o operador `$`:

.bg-lightest-blue.b-dark-blue.bw2.br3.ph4.mt2.-m[
📌 &nbsp;&nbsp;&nbsp;&nbsp; **Dica:** após escrever o `nome_do_dataframe$`, pressione a tecla `TAB` para ver as colunas disponíveis.
]

```{r}
mtcars$cyl

mtcars$gear

mtcars$mpg
```

---

### Data Frame

**Subsetting:**

Seleciona **elemento(s)** de um `data.frame` usando colchetes `[]`:&nbsp;&nbsp;&nbsp;&nbsp;`data_frame[linha, coluna]`

```{r}
# retorna o elemento presente na segunda linha da terceira coluna
mtcars[2, 3]

# retorna todas as linhas da coluna 1
mtcars[, 1]

# retorna todas as colunas da linha 1
mtcars[1, ]
```

---

### Data Frame

**Subsetting:** 

Seleção de **múltiplas colunas** de um `data.frame`:&nbsp;&nbsp;&nbsp;&nbsp;`data_frame[, c(coluna1, coluna2, ..., colunaN)]`

Há duas formas de fazer isso:

.pull-left[
```{r}
mtcars[, c(1, 2, 4)]
```
]

.pull-right[
```{r}
mtcars[, c("mpg", "cyl", "hp")]
```
]

---

### Data Frame

**Filtrando colunas:**

.panelset[

.panel[.panel-name[Exemplo 1]
```{r}
# seleciona apenas as linhas onde a coluna mpg é exatamente igual a é maior que 20

mtcars[mtcars$mpg > 20, ]
```
]

.panel[.panel-name[Exemplo 2]
```{r}
# seleciona apenas as linhas onde a coluna cyl 'é exatamente igual a 4

mtcars[mtcars$cyl == 4, ]
```
]

.panel[.panel-name[Exemplo 3]
```{r}
# seleciona apenas as linhas onde a coluna hp é menor que 100

mtcars[mtcars$hp < 100, ]
```
]

]

---

### Data Frame

É possível aplicar funções diretamente nas colunas de um `data.frame`:

```{r}
# valor mínimo da coluna mpg
min(mtcars$mpg)

# valor máximo da coluna mpg
max(mtcars$mpg)

# valor médio da coluna mpg
mean(mtcars$mpg)

# valor da mediana da coluna mpg
median(mtcars$mpg)
```

---

### Funções

Enquanto os objetos são nomes que armazenam valores, as **funções** são nomes que armazenam um **conjunto de instruções** em R. Sempre que uma função é executada, o código que ela contém roda automaticamente, e um resultado é devolvido.

As funções permitem **automatizar tarefas** e **evitar repetição de código**, de forma muito mais eficiente do que copiar e colar.

Na prática, as funções são tão comuns e intuitivas que você provavelmente já usou várias delas sem perceber. Aqui vão alguns exemplos que aparecem em seções anteriores:

- `c()` — cria vetores;

- `class()` — mostra a classe de um objeto;

- `dim()` — retorna as dimensões de um `data.frame` ou de uma `matriz`;

- `mean()` — calcula a média de um vetor;

- `max()` — retorna o valor máximo de um vetor.

---

### Funções

**Estrutura de uma Função:**

Uma função é composta por três partes principais:

- **Nome:** é como ela será identificada e chamada no ambiente R;

- **Argumentos:** são os valores (parâmetros) que a função recebe para funcionar;

- **Corpo:** o conjunto de instruções que será executado.

<br>

```{r, eval=FALSE, include=TRUE}
# estrutura para criar uma função
nome_da_funcao <- function(argumentos) {
  corpo da função
}

# para usar a função
nome_da_funcao(argumentos = ...)
```

---

### Funções

**Argumentos:**

Diferente dos objetos, as funções podem **receber argumentos** — valores colocados entre parênteses e que são usados internamente pela função para executar suas tarefas.

Por exemplo, a função `c()` precisa saber **quais valores formarão o vetor** que ela irá criar:

<br>

```{r}
c(1, 5, 10)
```

<br>

Nesse caso, os valores `1`, `5` e `10` são os **argumentos** passados para a função `c()`.

.bg-lightest-blue.b-dark-blue.bw2.br3.ph4.mt2.-m[
📌 &nbsp;&nbsp;&nbsp;&nbsp; **Dica:** os argumentos de uma função são sempre **separados por vírgulas**.
]

---

### Funções

**Argumentos:**

Cada função em R pode funcionar de forma diferente, mesmo quando realiza tarefas semelhantes. 

Por exemplo, a função `sum()` soma os valores passados como argumentos:

```{r}
sum(1, 3)
```

Também é possível passar um **vetor como argumento**, e o resultado será o mesmo:

```{r}
sum(c(1, 3))
```

Ou seja, a função `sum()` sabe lidar tanto com **valores separados** quanto com **vetores** como entrada.

---

### Funções

**Argumentos:**

Algumas funções exigem que os valores sejam passados de forma específica.

A função `mean()`, por exemplo, **espera um vetor como argumento** para calcular a média corretamente.

Veja a diferença:

```{r}
# só considera o primeiro número
mean(1, 3)

# considera os dois valores dentro de um vetor
mean(c(1, 3))
```

Ou seja, ao contrário de `sum()`, que aceita múltiplos argumentos separados, a `mean()` precisa receber **um único vetor** como entrada.

---

### Funções

**Argumentos:** 

Os argumentos de uma função também têm **nomes**, que podem (ou não) ser usados na hora de chamar a função.

Por exemplo, a função `seq()` possui (entre outros) os argumentos `from`, `to` e `by`:

```{r}
seq(from = 4, to = 10, by = 2)
```

Essa chamada cria uma **sequência numérica** que começa em `4` (`from`), vai até `10` (`to`), aumentando de `2` em `2` (`by`).

Também é possúvel usar a função **sem nomear os argumentos**, desde que os valores estejam na **ordem correta**:

```{r}
seq(4, 10, 2)
```

Ou seja, usar os nomes dos argumentos torna o código **mais legível** — mas não é obrigatório, se a ordem for respeitada.

---

### Funções

**Argumentos:** 

Quando é **especificado o nome dos argumentos**, a ordem deles **não importa**:

```{r}
seq(by = 2, to = 10, from = 4)
```

Mas, se **não usar os nomes dos argumentos**, a **ordem importa**, por o R vai associar os valores na sequência padrão (`from`, `to`, `by`):

```{r}
seq(2, 10, 4)
```

Ou seja:

- `r emo::ji("white_check_mark")` &nbsp;&nbsp; **com nomes:** a ordem pode ser trocada;



- `r emo::ji("x")` &nbsp;&nbsp; **sem nomes:** a ordem correta deve ser seguida para obter o resultado esperado.

---

### Funções

**Algumas Funções importantes do R base:**

<br>

| **Função**   |       **O que retorna?**      | **Função**   | **O que retorna?** |
|:-------------|:-----------------------------:|:------------:|:------------------:|
|   `head()`   |       6 primeiras linhas      |    `sum()`   |        soma        |
|   `tail()`   |        6 últimas linhas       |   `mean()`   |        média       |
|    `dim()`   |   número de linhas e colunas  |  `median()`  |       mediana      |
|   `names()`  | nomes das colunas (variáveis) |    `var()`   |      variância     |
|    `str()`   |    estrutura do data frame    |    `sd()`    |    desvio-padrão   |
|   `cbind()`  |      acopla duas tabelas      |    `max()`   |    valor máximo    |
|   `rbind()`  |      empilha duas tabelas     |    `min()`   |    valor mínimo    |
|   `class()`  |        classe do objeto       |   `round()`  |  valor arredondado |

---

### Pacotes

Pacotes são **coleções de funções, dados e documentação** que estendem as funcionalidades do R base.

Para usá-los, é preciso primeiro **instalar** e depois **carregar** o pacote.

Um dos pacotes mais populares e poderosos do R é o `tidyverse`, que reúne diversas ferramentas para ciências de dados.

```{r, fig.align='center', echo=FALSE, out.width='400px', dpi=300}
knitr::include_graphics("img/17-icon-packages.jpg")
```

---

### Pacotes

**Instalação dos Pacotes:**

<br>

- Via CRAN (*Comprehensive R Archive Network*):

`install.packages("nome_do_pacote")`

```{r, include=TRUE, eval=FALSE}
install.packages("tidyverse")
```

<br><br>

- Via GitHub:

`devtools::install_github("nome-do-repositorio/nome_do_pacote")`

```{r, include=TRUE, eval=FALSE}
devtools::install_github("tidyverse/dplyr")
```

---

### Pacotes

`library(nome_do_pacote)`

```{r, include=TRUE, eval=FALSE}
library(tidyverse)
```

Também há outra opção: `nome_do_pacote::nome_da_funcao()`.

```{r, include=TRUE, eval=FALSE}
dplyr::glimpse()
```

<br>

----

<br>

**Dicas sobre os Pacotes:**

1. Só é necessário **instalar** um pacote **uma vez**, mas é necessário **carregá-lo sempre que iniciar uma nova sessão**.

2. Para **instalar** um pactore, use aspas: &nbsp;&nbsp; `install.packages("nome_do_pacote")`.

3. Para **carregar** um pacote, não use aspas: &nbsp;&nbsp; `library(nome_do_pacote)`.

---

## Continue aprendendo!

.panelset[

.panel[.panel-name[Em Português]
.pull-left[
- [Material da Curso-R](https://livro.curso-r.com/)

<a href="http://material.curso-r.com/">
```{r echo=FALSE, out.width="45%", fig.align='center'}
knitr::include_graphics("img/18-cursor.png")
```
</a>
]

.pull-right[
- [R para Ciência de Dados (2ª edição)](https://pt.r4ds.hadley.nz)

<a href="https://pt.r4ds.hadley.nz">
```{r echo=FALSE, out.width="55%", fig.align='center'}
knitr::include_graphics("img/19-r4ds.jpg")
```
</a>
]
]

]

---

class: inverse center middle
name: projetos

# Projetos 

---

## Projetos

Um Projeto é uma pasta no computador que reúne todos os arquivos necessários para realizar uma análise de dados.

A principal razão para a utilização dos Projetos é a **organização**. Com eles, é muito mais fácil importar bases de dados para dentro do `R`, criar análises reprodutíveis e compartilhar o trabalho com outras pessoas.

<br>

<div style="text-align: center;">
  <strong style="font-size: 150%;">Habitue-se, desde cedo, a criar um projeto para cada nova análise.</strong>
</div>

<br>

Para **criar um projeto**, clique em `New Project` no menu `File`. Na janela que se abrir, escolha `New Directory` para criar o projeto em uma nova pasta, ou `Existing Directory` para usar uma pasta que já existe.

Ao criar um projeto, o `RStudio` cria um arquivo `nome-do-projeto.Rproj` na pasta escolhida. Esse arquivo guarda as configurações do projeto e pode ser usado para abrir o `RStudio` diretamente nele.

.footnote[Com o `Git` instalado, pode usar projetos para conectar com repositórios remotos e versionar o código ([GitHub](https://github.com], por exemplo). Para isso, basta clicar em `Version Control`. Para maiores informações, acesse o [Zen do R](https://blog.curso-r.com/posts/2019-07-23-zen-do-r-4/) e o <i>workshop</i> [Introdução a utilização do Git e Github no RStudio](https://www.youtube.com/watch?v=uQL6NOSd9cc) da [Beatriz Milz](https://twitter.com/BeaMilz).]

---

### Projetos

**Criando um novo Projeto:**

```{r, echo=FALSE, out.width="80%", fig.align='center'}
knitr::include_graphics("img/20-criar-projeto.gif")
```

---

### Projetos

**RStudio com um Projeto aberto:**

```{r, echo=FALSE, out.width="70%", fig.align='center'}
knitr::include_graphics("img/21-exemplo-projeto-aberto.png")
```

---

### Projetos

**Navegando entre os Projetos:**

```{r, echo=FALSE, out.width="70%", fig.align='center'}
knitr::include_graphics("img/22-exemplo-lista-projetos.png")
```

---

### Pacote: `tidyverse`

É uma coleção de pacotes de `R` desenvolvidos para a Ciência de Dados. 

Os pacotes do `tidyverse` compartilham uma mesma filosofia de desenvolvimento, sintaxe e estruturas de dados. 

Embora o `tidyverse` instale diversos outros pacotes, apenas esses são carrregados: 

<br>


|     **Pacote**    |                      **Função**                      |
|:-----------------:|:----------------------------------------------------:|
|      `tibble`     |               _data frames_ repaginados              |
|      `readr`      | leitura e importação de dados (e.g. `.csv` e `.txt`) |
| `tidyr` e `dplyr` |           arrumação e manipulação de dados           |
|     `stringr`     |                  trabalha com textos                 |
|     `forcats`     |                 trabalha com fatores                 |
|      `purrr`      |                 programação funcional                |
|     `ggplot2`     |           visualização de dados (gráficos)           |

---

class: inverse center middle
name: importacao

# Importação de dados

---

### Caminhos

É importante na tarefa de **importação de dados** saber onde está o arquivo que se quer importar. Toda função de importação vai exigir um **caminho** (uma _string_) que representa o endereço do arquivo no computador.

<br>

----

**Diretório de trabalho (_working directory_):**

É a pasta em que o **R** vai procurar os arquivos na hora de ler as informações ou gravar os arquivos na hora de salvar os objetos.

Se está dentro de um Projeto, o diretório de trabalho será, por padrão, a pasta raiz do Projeto (é a pasta que contém o arquivo `.Rproj`).

Se não estiver usando um Projeto ou não souber qual é o diretório de trabalho, é possível descobri-lo usando a função `getwd()`. Ela vai devolver uma _string_ com o caminho do diretório de trabalho.

A função `setwd()` pode ser utilizada para mudar o diretório de trabalho. Como argumento, ela recebe o caminho para o novo diretório.

---

### Caminhos

**Caminhos absolutos:**

São aqueles que têm início na pasta raiz do computador/usuário. Por exemplo: `/Users/luisagisele/Repositorio/workshop-r`.

**Caminhos absolutos** são uma **má prática**. Se você trocar de computador ou passar o _script_ para outra pessoa, o código não vai funcionar. Isso ocorre porque o caminho absoluto de um arquivo, muito provavelmente, será diferente entre os computadores.

<br>

----

**Caminhos relativos:**

São aqueles que têm início no diretório de trabalho da sessão. Usando o exemplo de caminho absoluto acima, o caminho relativo é: `workshop-r`.

O uso de **caminhos relativos** dentro de um projeto é considerado uma **boa prática**, pois quando a pasta do projeto for compartilhado com alguém, todos os caminhos existentes no código continuarão funcionando em qualquer computador.

---

## Tibbles

São uma evolução da classe `data.frame`.

As funções do **`tidyverse`** para importação, arrumação e manipulação de bases devolvem sempre `tibbles` em vez de `data.frames`.

Embora existam outras diferenças entre as classes, a mais importante é a forma como a tabela é mostrada no _console_.

Quanto a isso, as diferenças são:

- `tibbles` mostram o número de linhas, o número de colunas e a classe das variáveis;

- `tibbles` mostram apenas as 10 primeiras linhas;

- `tibbles` mostram o número de colunas que couber na tela do _console_.

- `tibbles` não nomeiam linhas (`row.names`).

---

### Tibbles

**Exemplo: base `mtcars` como `data.frame`**

```{r, echo=FALSE}
head(mtcars, n = 15)
```

---

### Tibbles

**Exemplo: base `mtcars` como `tibble`**

```{r}
tibble::as_tibble(mtcars)
```

**Perceba que a coluna com os nomes dos modelos dos veículos desaparece na `tibble`.** Isso acontece porque, no `data.frame`, esses nomes fazem parte dos **nomes das linhas (`row.names`)**, e não de uma coluna propriamente dita. Já nas `tibbles`, os nomes das linhas **não são exibidos nem armazenados da mesma forma**, o que pode dar a impressão de que a "coluna" foi excluída.

---

### Tibbles

**Exemplo: base `mtcars` como `tibble`**

Uma maneira de **preservar os nomes dos modelos dos veículos** como coluna ao converter um `data.frame` em `tibble` é utilizar o argumento `rownames = "nome_da_coluna"` dentro da função `as_tibble()`. Assim, a nova `tibble` terá **12 colunas** — uma a mais que a anterior, pois agora os nomes dos modelos passam a fazer da base como uma variável explícita.

```{r}
tibble::as_tibble(mtcars, rownames = "cars")
```

---

### [Cheat Sheets](https://posit.co/resources/cheatsheets/) 

[![Cheat Sheets](img/23-cheatsheet-readr.png)](https://rstudio.github.io/cheatsheets/data-import.pdf)

---

### Importação de arquivos

- Pacote [`readr`](https://readr.tidyverse.org): utilizados para ler arquivos de texto

  - `read_csv()`: lê arquivos `.csv` (valores separados por vírgula)
  
  - `read_csv2()`: lê arquivos `.csv` (valores separados por ponto e vírgula)
  
  - `read_delim()`: lê arquivos `.txt` (valores separados por tabulação)
  
  - `read_rds()`: lê arquivos `.rds` (formato nativo do R)

- Pacote [`readxl`](https://readxl.tidyverse.org): utilizado para ler arquivos do Excel

  - `read_excel()`: lê arquivos `.xls` e `.xlsx`
  
- Pacote [`haven`](https://haven.tidyverse.org): utilizado para ler arquivos do SPSS, Stata e SAS

  - `read_sas()`: lê arquivos `.sas7bdat`
  
  - `read_spss()`: lê arquivos `.sav`
  
  - `read_dta()`: lê arquivos `.dta`
  
  - `read_stata()`: lê arquivos `.dta`
  
---

### Importação de arquivos

Para ler arquivos de texto (`.csv` ou `.txt`), são utilizadas funções do pacote [`readr`](https://readr.tidyverse.org).

Como exemplo, vamos utilizar a base dos Pinguins, originalmente disponibilizado no pacote [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/), que contém dados sobre pinguins da Antártica. 

Essa base também pode ser encontrado traduzido para o português no pacote [`dados`](https://cienciadedatos.github.io/dados/).

Vamos importar essa base para o **R** lendo o arquivo `pinguins.csv` que está dentro da para `dados`. Para isso, utilizamos a função `read_csv()` do pacote `readr`. 

Se o arquivo estiver bem formatado, a função só precisará do caminho até o arquivo para funcionar.

```{r}
library(readr) # carrega o pacote responsável pela importação

pinguins_csv <- read_csv("dados/pinguins.csv")
```

---

### Importação de arquivos

O objeto resultante será um `tibble`:

```{r}
pinguins_csv
```

---

### Importação de arquivos

Em alguns países, como o Brasil, as vírgulas são utilizadas para separar as casas decimais dos números, inviabilizando os arquivos `.csv`.

Nesse caso, os arquivos são separados por ponto-e-vírgula (;). Para ler essas bases no **R**, basta usar a função `read_csv2()` do pacote [`readr`](https://readr.tidyverse.org).

```{r}
library(readr) # carrega o pacote responsável pela importação

pinguins_csv2 <- read_csv2("dados/pinguins2.csv")
```

<br>

----

Arquivos `.txt` podem ser lidos com a função `read_delim()`. Nesse caso, além do caminho até o arquivo, é preciso indicar qual é o caractere utilizado para separar as colunas da base.

Um arquivo separado por tabulação, por exemplo, pode ser lido utilizando o argumento `delim = "\t"`. O código `\t` é uma forma textual de representar a tecla `TAB`.

```{r}
library(readr) # carrega o pacote responsável pela importação

pinguins_txt <- read_delim("dados/pinguins.txt", delim = "\t")
```

---

### Importação de arquivos

**Arquivos direto da Internet:** 

É possível importar dados diretamente da internet. Para isso, basta colocar o _link_ do arquivo/tabela entre aspas no caminho do arquivo.

```{r eval = FALSE, include = TRUE}
titanic <- read_csv(
  "https://raw.githubusercontent.com/beatrizmilz/2020-R-Ladies-SP-Basico/master/docs/data/titanic.csv"
)
```

<br>

----

**Arquivos Excel:** 

Para ler planilhas do Excel (arquivos `.xlsx` ou `.xls`) utilizamos a função `read_excel()` do pacote [`readxl`](https://readxl.tidyverse.org). 

Como esse pacote não faz parte do `tidyverse`, é necessário instalá-lo separadamente. 

```{r eval = FALSE, include = TRUE}
library(readxl) # carrega o pacote

readxl::pinguins_xlsx <- read_excel("dados/pinguins.xlsx")
```

---

### Importação de arquivos

**Arquivos Excel: argumentos úteis**

Planilhas do Excel são facilmente editáveis — e por isso, é comum recebermos bases de dados **desconfiguradas**, ou seja, em um formato que o **R** não consegue importar diretamente.

Para evitar ter que arrumar "na mão", correndo o risco de cometer erros ou alterar dados sem querer, a função `read_excel()` oferece argumentos que ajudam a importar a base corretamente.

Principais argumentos:

- `sheet =`: indica qual aba da planilha deve ser importada.  _(Padrão: primeira aba)_

- `col_names =`: define se a primeira linha contém os nomes das colunas.  _(Padrão: `TRUE`)_

- `col_types =`: especifica o tipo de dado de cada coluna (ex: `"text"`, `"numeric"` etc).  _(Padrão: `"guess"`)_

- `skip =`: pula um número definido de linhas antes da leitura.  _(Padrão: `0`)_

- `n_max =`: define quantas linhas devem ser lidas.  _(Padrão: `Inf`)_

- `NA =`: indica quais valores devem ser interpretados como `NA`.  _(Padrão: `""`)_

---

### Exportação de arquivos

Exportar objetos do **R** significa gravar as bases (ou objetos) em um arquivo no disco rígido (HD) do computador.

De forma geral, para cada função `read_*()` usada na importação, existe uma função correspondente `write_*()` para exportação.

Essas funções são simples: você precisa informar **o objeto que deseja salvar** e o **caminho com o nome do arquivo** (incluindo a extensão!).

```{r eval = FALSE, include = TRUE}
library(readr)  # funções write_csv, write_csv2, write_delim

# CSV com vírgula
write_csv(pinguins, "dados/pinguins.csv")
# CSV com ponto-e-vírgula (mais comum em PT-BR)
write_csv2(pinguins, "dados/pinguins2.csv")

# Arquivo TXT com tabulação
write_delim(pinguins, "dados/pinguins.txt", delim = "\t")
```

Para salvar arquivos em formato **Excel** `.xlsx`, usamos a função `write_xlsx()` do pacote [`writexl`](https://writexl.tidyverse.org), que precisa ser carregado separadamente.

```{r eval = FALSE, include = TRUE}
library(writexl) # carrega o pacote

write_xlsx(pinguins, "dados/pinguins.xlsx")
```

---

### Importação e exportação de arquivos

**Extensão `.rds`**

A extensão `.rds` representa uma estrutura binária de arquivo nativa do R.  
Ela pode ser usada para salvar **qualquer objeto** — não apenas data frames ou tibbles — no disco rígido (HD).

Quando aplicada a conjuntos de dados, essa estrutura binária permite **compactação**, gerando arquivos significativamente menores em comparação com formatos como `.csv`.

Para criar e ler arquivos `.rds`, utilizamos as funções `write_rds()` e `read_rds()`, ambas do pacote [`readr`](https://readr.tidyverse.org).

```{r eval = FALSE, include = TRUE}
library(readr)  # pacote necessário

# escrevendo SEM compactação
write_rds(pinguins, "dados/pinguins.rds")

# escrevendo COM compactação
write_rds(pinguins, "dados/pinguins.rds", compress = "gz")

# lendo a base diretamente
read_rds("dados/pinguins.rds")

# importando para um objeto
pinguins_rds <- read_rds("dados/pinguins.rds")
```

---
  
### Visualização de um objeto
  
**Para visualizar um objeto em aba separada:**

É possível visualizar os dados (ou parte deles) de forma mais confortável clicando no nome do objeto no painel `Global Environment` (aba `Environment`) do RStudio.

Outra opção é usar a função `View(nome_da_base)` diretamente:

```{r eval = FALSE, include = TRUE}
View(pinguins_csv)
```

Isso abrirá o conteúdo do objeto em uma nova aba, com aparência de planilha.

```{r echo=FALSE, out.width="100%", fig.align='center'}
knitr::include_graphics("img/24-view-pinguins.png")
```

---

### Visualização de um objeto

**Para visualizar uma base no _Console_:**

É possível "espiar" os dados de uma forma rápida usando a função `glimpse()` do pacote [`dplyr`](https://dplyr.tidyverse.org). 

Essa função mostra: 

- o número de observações (linhas) e variáveis (colunas), 
- os nomes e tipos das colunas, 
- e alguns valores iniciais de cada variável.

```{r}
library(dplyr)  # carrega o pacote necessário

glimpse(pinguins_csv)
```

---

### <span style='color:#34a15a'>BASE DOS DADOS</span>

A <span style='color:#34a15a'><b>Base dos Dados</b></span> é uma organização não governamental, sem fins lucrativos e <span style='color:#34a15a'><b>open source</b></span>, que atua para universalizar o acesso a <span style='color:#34a15a'><b>dados públicos de qualidade</b></span>.

Em seu repositório, você encontra <span style='color:#34a15a'><b>dados brasileiros já tratados, limpos e padronizados</b></span>, prontos para serem importados diretamente para o **R** por meio do pacote [`basedosdados`](https://basedosdados.org/blog/como-acessar-dados-publicos-em-r).

Além disso, os responsáveis pela <span style='color:#34a15a'><b>Base dos Dados</b></span> mantêm um repositório com os códigos das análises que publicam em _workshops_, redes sociais, artigos e tutoriais.

[![GitHub da Base dos Dados](img/25-base-dos-dados-github.png)](https://github.com/basedosdados/analises)

---

### <span style='color:#34a15a'>BASE DOS DADOS</span>

É possível realizar o _download_ de arquivos `.csv` completos diretamente pelo site.

Entretanto, esse tipo de acesso <span style='color:#34a15a'><b>não está disponível para arquivos muito grandes</b></span>.

----

Para esses casos, utiliza-se o <span style='color:#34a15a'><font size='5'><b>BigQuery:</b></font></span>

Um serviço de banco de dados em nuvem da Google, que permite realizar consultar em linguagem `SQL` diretamente do navegador, com:

- <span style='color:#34a15a'><b>Rapidez:</b></span> mesmo _queries_ complexas são processadas em poucos minutos;

- <span style='color:#34a15a'><b>Escalabilidade:</b></span> o BigQuery se ajusta automaticamente, podendo lidar com volumes gigantescos (até <span style='color:#34a15a'><b>exabytes</b></span>, se necessário);

- <span style='color:#34a15a'><b>Economia:</b></span> todo usuário tem direito a <span style='color:#34a15a'><b>1 TB gratuito por mês</b></span> em consultas.

<br>

<div style="text-align: center;">
  <strong style="font-size: 130%; color: #34a15a;">
    O uso do BigQuery é gratuito até 1 TB/mês. Acima disso, há cobrança por volume de dados processados.
  </strong>
</div>

---

### <span style='color:#34a15a'>BASE DOS DADOS</span>

<span style='color:#34a15a'><b>Como criar um projeto no BigQuery:</b></span>

Para criar um Projeto no _Google Cloud_, basta ter uma conta de e-mail do Google.

Mesmo que você pretenda carregar dados próprios, é necessário criar um Projeto (mesmo vazio) para poder executar _queries_ no _datalake_ público da <span style='color:#34a15a'>Base dos Dados</span>.

1. [Acesse o Google Cloud](https://console.cloud.google.com/projectselector2/home/dashboard). Se for sua primeira vez, aceite os Termos de Serviço.

2. Clique em `Create Project` / `Criar Projeto` e escolha um nome bacana para o projeto.

3. Confirme em `Create` / `Criar`.

Para mais detalhes, consulte a [documentação oficial](https://cloud.google.com/bigquery/docs/sandbox/?hl=pt).

.footnote[
<span style='color:#34a15a'><b>Por que é preciso criar um projeto no Google Cloud?</b></span>
A Google oferece <span style='color:#34a15a'><b>1 TB gratuito por mês</b></span> de uso do BigQuery <span style='color:#34a15a'><b>para cada projeto</b></span>. Você <span style='color:#34a15a'><b>não precisa cadastrar cartão de crédito</b></span> — o BigQuery inicia automaticamente no modo _Sandbox_, que permite usar os recursos <span style='color:#34a15a'><b>sem configurar forma de pagamento</b></span>.
]

---

### <span style='color:#34a15a'>BASE DOS DADOS</span>

<span style='color:#34a15a'><b>Como criar um projeto no BigQuery</b></span>

<span style='color:#34a15a'><b>Habilitar o projeto no R:</b></span>

```r
install.packages("basedosdados")  # instala o pacote

library(basedosdados)  # carrega o pacote

# identifique o projeto sempre que iniciar uma nova sessão no R
set_billing_id("id-do-projeto")
```

Na primeira vez que acessar o _Google Cloud_ pelo **R**, uma página do Google será aberta solicitando a autorização para vincular sua conta ao pacote [`basedosdados`](https://basedosdados.org/blog/como-acessar-dados-publicos-em-r).

----

No canal da [Base dos Dados](https://www.youtube.com/@BasedosDados) no Youtube, há um _Workshop_ ensinando a acessar os dados públicos em **R**: [acesse aqui](https://www.youtube.com/watch?v=M9ayiseIjvI).

No blog da [Base dos Dados](https://dev.to/basedosdados), há um tutorial de como usar a biblioteca [`basedosdados`](https://basedosdados.org/blog/como-acessar-dados-publicos-em-r) no **R**: [acesse aqui](https://dev.to/basedosdados/como-usar-a-biblioteca-basedosdados-no-r-capitulo-1-46kb).


---

### <span style='color:#34a15a'>BASE DOS DADOS</span>

<span style='color:#34a15a'><b>Como criar um projeto no BigQuery</b></span>

```{r echo=FALSE, out.width="85%", fig.align='center'}
knitr::include_graphics("img/26-big-query-projeto-r.gif")
```

---

### <span style='color:#34a15a'>BASE DOS DADOS</span>

<span style='color:#34a15a'><b>Como fixar o projeto da Base dos Dados (BD) no seu BigQuery:</b></span>

```{r echo=FALSE, out.width="80%", fig.align='center'}
knitr::include_graphics("img/27-fixa-bd-no-bigquery.gif")
```

---

### <span style='color:#34a15a'>BASE DOS DADOS — SQL</span>

**SQL** (_Structured Query Language_, ou _Linguagem de Consulta Estruturada_) é a linguagem padrão para **consultas em bancos de dados relacionais**.

Ela permite selecionar, filtrar, agrupar e combinar dados de forma declarativa — ou seja, dizendo o que você quer, e não como fazer.

----

<span style='color:#34a15a'><b>Principais cláusulas (palavras-chave):</b></span>

  - **SELECT**: seleciona as colunas desejadas (é o comando principal do SQL)  

  - **FROM**: especifica a tabela de onde os dados serão extraídos  

  - **WHERE**: define condições (filtros) para os dados selecionados  

  - **GROUP BY**: agrupa os dados com base em uma ou mais colunas  

  - **HAVING**: filtra os grupos criados pelo `GROUP BY`  

  - **ORDER BY**: ordena os dados com base em uma ou mais colunas  

  - **DISTINCT**: remove valores duplicados da seleção  

  - **UNION**: combina os resultados de duas consultas SQL em uma só tabela

---

### <span style='color:#34a15a'>BASE DOS DADOS — SQL</span>

<span style='color:#34a15a'><b>Palavras-chave – Operadores Lógicos:</b></span>

- **AND**: retorna verdadeiro se **todas as condições** forem verdadeiras  

- **OR**: retorna verdadeiro se **pelo menos uma condição** for verdadeira  

- **NOT**: inverte o resultado lógico da condição (retorna o oposto)

----

<span style='color:#34a15a'><b>Palavras-chave – Funções de Agregação:</b></span>

- **AVG**: calcula a média dos valores em um campo  

- **COUNT**: retorna o número de registros selecionados  

- **SUM**: soma os valores de um campo  

- **MAX**: retorna o maior valor em um campo  

- **MIN**: retorna o menor valor em um campo  

- **STDDEV**: calcula o desvio padrão dos valores  

- **VARIANCE**: calcula a variância dos valores

---

### <span style='color:#34a15a'>BASE DOS DADOS — SQL</span>

<span style='color:#34a15a'><b>Palavras-chave – Operadores relacionais:</b></span>

- **<** (_MENOR_): seleciona registros com valores **menores do que** a condição especificada  

- **>** (_MAIOR_): seleciona registros com valores **maiores do que** a condição especificada  

- **<=** (_MENOR OU IGUAL_): seleciona registros com valores **menores ou iguais a** determinada condição  

- **>=** (_MAIOR OU IGUAL_): seleciona registros com valores **maiores ou iguais a** determinada condição  

- **=** (_IGUAL_): seleciona registros com valores **iguais a** determinada condição  

- **<>** (_DIFERENTE_): seleciona registros com valores **diferentes de** determinada condição

<br>

- **BETWEEN**: seleciona registros com valores **dentro de um intervalo fechado** (inclui os limites)  

- **LIKE**: seleciona registros que **correspondem a um padrão de texto**  

- **IN**: seleciona registros cujo valor **está presente em uma lista definida**

---

### <span style='color:#34a15a'>BASE DOS DADOS — SQL</span>

<div class="panelset">

<div class="panel">
<div class="panel-name">Ex. Fictício</div>

```{sql eval = FALSE, include = TRUE}
-- consulta sem filtro

SELECT coluna1, coluna2, coluna3,
       coluna4 AS apelido_da_coluna
FROM `tabela`
```

Imagine que a base seja muito grande e você não irá utilizar todos os dados.

É recomendado <span style='color:#34a15a'><b>filtrar</b></span> os dados ainda na consulta, antes de importá-los para o **R**.

```{sql eval = FALSE, include = TRUE}
-- consulta com filtro

SELECT coluna1, coluna2, coluna3,
       coluna4 AS apelido_da_coluna
FROM `tabela`
WHERE coluna1 = valor AND coluna2 = valor
```

</div>

<div class="panel">
<div class="panel-name">Ex. Real (sem filtro)</div>

```{sql eval = FALSE, include = TRUE}
-- Consulta selecionando colunas específicas

SELECT id_municipio, nome_regiao
FROM `basedosdados.br_bd_diretorios_brasil.municipio`
```

<br>

Para selecionar <span style='color:#34a15a'><b>todas as colunas</b></span> de uma tabela, use `*` após o `SELECT`.

``` {sql eval = FALSE, include = TRUE}
-- Consulta selecionando todas as colunas

SELECT *
FROM `basedosdados.br_bd_diretorios_brasil.municipio`
```

</div>

<div class="panel">
<div class="panel-name">Ex. Real (com filtro)</div>

```{sql eval = FALSE, include = TRUE}
-- Média da taxa de aprovação e IDEB por município e ensino

SELECT id_municipio, ano,
       AVG(taxa_aprovacao) AS tx_aprov,
       ensino,
       AVG(ideb) AS ideb
FROM `basedosdados.br_inep_ideb.municipio`
WHERE ano = 2021
GROUP BY id_municipio, ano, ensino
```

</div>

<div class="panel">
<div class="panel-name">Ex. com JOIN</div>

```{sql eval = FALSE, include = TRUE}
-- Junção entre PIB e população por município

SELECT pib.id_municipio, pib.ano,
       pop.id_municipio, pop.populacao
FROM `basedosdados.br_ibge_pib.municipio` AS pib
LEFT JOIN `basedosdados.br_ibge_populacao.municipio` AS pop
ON pib.id_municipio = pop.id_municipio
```

<br>

<span style='color:#34a15a'><b>Palavras-Chave:</b></span>

- **AS:** define um "apelido" para a coluna e/ou para a tabela

- **LEFT JOIN:** une duas tabelas em uma mesma base de dados

- **ON:** define a "chave" que liga as duas tabelas

</div>

</div>

---

### <span style='color:#34a15a'>BASE DOS DADOS — SQL</span>

```{r echo=FALSE, out.width="90%", fig.align='center'}
knitr::include_graphics("img/28-ex-download-bigquery-r.gif")
```

---

### <span style='color:#34a15a'>BASE DOS DADOS — SQL</span>

Para que o **R** consiga importar os dados da consulta `SQL`, é necessário utilizar a função `read_sql()` do pacote [`basedosdados`](https://basedosdados.org/blog/como-acessar-dados-publicos-em-r) ao final da _query_.

Existem duas formas de fazer isso:

<span style='color:#34a15a'><b>1. Criando um objeto intermediário com a consulta `SQL` e, depois, o objeto final com os dados:</b></span>

```{r eval=FALSE, include=TRUE}
library(basedosdados) # pacote necessário

obj_intermediario <- "SELECT id_municipio, nome_regiao
FROM `basedosdados.br_bd_diretorios_brasil.municipio`"

base_final <- basedosdados::read_sql(obj_intermediario)
```


<span style='color:#34a15a'><b>2. Utilizando o operador `pipe` (`%>%` ou `|>`) para encadear a consulta diretamente à função `read_sql()`:</b></span>

```{r eval=FALSE, include=TRUE}
library(basedosdados) # pacote necessário

base_final <- "SELECT id_municipio, nome_regiao
FROM `basedosdados.br_bd_diretorios_brasil.municipio`" |> 
  read_sql()
```

---


